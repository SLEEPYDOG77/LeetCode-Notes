# 题目

## 中文

给定一个数组，将数组中的元素向右移动 `k` 个元素，其中 `k` 是非负数。

## 英文

Given an array, rotate the array to the right by k steps, where k is non-negative.

# 示例

### Example 1:

```sh
Input: [1,2,3,4,5,6,7] and k = 3
Output: [5,6,7,1,2,3,4]
Explanation:
rotate 1 steps to the right: [7,1,2,3,4,5,6]
向右旋转 1 步: [7,1,2,3,4,5,6]
rotate 2 steps to the right: [6,7,1,2,3,4,5]
向右旋转 2 步: [6,7,1,2,3,4,5]
rotate 3 steps to the right: [5,6,7,1,2,3,4]
向右旋转 3 步: [5,6,7,1,2,3,4]
```



### Example 2: 

```
Input: [-1,-100,3,99] and k = 2
Output: [3,99,-1,-100]
Explanation: 
rotate 1 steps to the right: [99,-1,-100,3]
向右旋转 1 步: [99,-1,-100,3]
rotate 2 steps to the right: [3,99,-1,-100]
向右旋转 2 步: [3,99,-1,-100]
```



# 说明

## 中文

- 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
- 要求使用空间复杂度为 O(1) 的**原地**算法。

## 英文

- Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.
- Could you do it in-place with O(1) extra space?

# 算法

## 方法（1）



#### 时间复杂度

#### 空间复杂度

## 方法（2）



#### 时间复杂度

#### 空间复杂度

## 方法（3）



#### 时间复杂度

#### 空间复杂度

# 代码

## C++

```C++
#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
		// 方法（1）
    void rotate_1(vector<int>&nums, int k) {
        int n = nums.size();

        // 额外存储空间 存储最后 k 个元素
        vector<int> temp(nums.end() - k, nums.end());
        
        // 前 n - k 个元素 依次后移 k 位
        for (int i = n-k; i > 0; i--) {
            nums[i+k] = nums[i];
        }

        // 再将最后 k 个元素 拼接在原数组之前
        for (int i = 0; i < k; i++) {
            nums[i] = temp[i];
        }
    }
  
		// 方法（2）
    void rotate_2(vector<int>& nums, int k) {

        int len = nums.size();
        k %= len;
        if (k == 0) {
            return;
        }

        reverse(nums.begin(), nums.end() - k);  // 先反转前 n-k 个元素
        reverse(nums.end() - k, nums.end());    // 再反转后面 k 个元素
        reverse(nums.begin(), nums.end());      // 最后反转全部的元素
    }

  	// 方法（3）
    void rotate_3(vector<int>& nums, int k) {
        int len = nums.size();
        int temp1 = 0;  // 辅助存储变量
        int temp2 = 0;  // 辅助存储变量
        int index = 0;
        int count = 0;  // 计数，记录移动的次数

        k %= len;
        if (k == 0) {
            return;
        }

        // i 代表当前所在闭环的首元素下标
        for (int i = 0; i <= k; i++) {

            // 如果已经每个元素都移动过了，则退出循环
            if (count >= len) {
                break;
            }

            index = i;
            temp1 = nums[i];

            // 一个闭环
            while ((index + k)%len != i) {
                temp2 = nums[(index + k)% len];
                nums[(index + k)% len] = temp1;
                index = (index + k) % len;
                temp1 = temp2;
                count++;
            }
            nums[i] = temp1;
            count++;
        }
    }
};

int main() {
    int arr[] = {-1,-100,3,99};
    int k = 2;
    vector<int> nums(arr, arr+4);
    Solution test;
    test.rotate_1(nums, k);
    for(int i = 0; i < 4; i++) {
        cout << nums[i] << '\t';
    }
    cout << endl;

    return 0;
}
```



## C

```c
void rotate(int* nums, int numsSize, int k) {

    // 方法2：
    int temp1;
    int temp2;
    int index;
    int count = 0;
    k %= numsSize;
    for (int i = 0; i <= k; i++) {
        if (count >= numsSize) {
            break;
        }
        index = i;
        temp1 = nums[i];
        while((index + k) % numsSize != i) {
            temp2 = nums[(index +k) % numsSize];
            nums[(index + k) % numsSize] = temp1;
            index = (index + k) % numsSize;
            temp1 = temp2;
            count++;
        }
        nums[i] = temp1;
        count++;
    }
}
```

